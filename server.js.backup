const express = require('express'); const eventHandlers = require('./src/handlers'); const logger = 
require('./src/utils/logger'); const app = express(); const PORT = process.env.PORT || 3000;
// ä¸­é—´ä»¶
app.use(express.json({ limit: '10mb' }));
// å¥åº·æ£€æŸ¥ç«¯ç‚¹
app.get('/health', (req, res) => { res.json({ status: 'healthy', timestamp: new Date().toISOString(), service: 
    'emby-dingtalk-notifier', version: '1.0.0'
  });
});
// é’‰é’‰è¿æ¥æµ‹è¯•ç«¯ç‚¹
app.get('/test/dingtalk', async (req, res) => { try { const dingtalk = require('./src/adapters/dingtalk'); 
    const result = await dingtalk.testConnection(); res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
// Emby Webhook æ¥æ”¶ç«¯ç‚¹
app.post('/webhook', async (req, res) => { try { const data = req.body; const event = data.Event;
    
    logger.info(`æ”¶åˆ° Emby Webhook äº‹ä»¶: ${event}`, { user: data.UserName, item: data.ItemName, device: 
      data.DeviceName
    });
    
    // æŸ¥æ‰¾å¯¹åº”çš„å¤„ç†å™¨
    const handler = eventHandlers[event];
    
    if (handler) { await handler(data); res.json({ status: 'success', message: 'äº‹ä»¶å¤„ç†æˆåŠŸ', event: event
      });
    } else {
      logger.warn(`æœªå¤„ç†çš„äº‹ä»¶ç±»å‹: ${event}`); res.json({ status: 'ignored', message: 'äº‹ä»¶ç±»å‹è¢«å¿½ç•¥', 
        event: event
      });
    }
  } catch (error) {
    logger.error('Webhook å¤„ç†å¤±è´¥:', error); res.status(500).json({ status: 'error', message: 'äº‹ä»¶å¤„ç†å¤±è´¥', 
      error: error.message
    });
  }
});
// æµ‹è¯•ç‰¹å®šäº‹ä»¶ç«¯ç‚¹
app.post('/test/:eventType', async (req, res) => { const eventType = req.params.eventType; const testData = { 
    Event: eventType, UserName: 'æµ‹è¯•ç”¨æˆ·', ItemName: 'æµ‹è¯•å½±ç‰‡', DeviceName: 'Chromeæµè§ˆå™¨', Client: 'Emby 
    Web', RemoteEndPoint: '192.168.1.100', Timestamp: new Date().toISOString(), ...req.body
  };
  
  try { const handler = eventHandlers[eventType]; if (handler) { await handler(testData); res.json({ status: 
        'success', message: 'æµ‹è¯•æ¶ˆæ¯å‘é€æˆåŠŸ', event: eventType
      });
    } else {
      res.status(404).json({ error: 'æœªæ‰¾åˆ°å¯¹åº”çš„äº‹ä»¶å¤„ç†å™¨' });
    }
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
// 404 å¤„ç†
app.use('*', (req, res) => { res.status(404).json({ error: 'æ¥å£ä¸å­˜åœ¨' });
});
// å…¨å±€é”™è¯¯å¤„ç†
app.use((error, req, res, next) => { logger.error('æœåŠ¡å™¨é”™è¯¯:', error); res.status(500).json({ error: 
  'å†…éƒ¨æœåŠ¡å™¨é”™è¯¯' });
});
// å¯åŠ¨æœåŠ¡å™¨
app.listen(PORT, () => { console.log(`ğŸš€ Emby Dingtalk Notifier æœåŠ¡å·²å¯åŠ¨`); console.log(`ğŸ“ æœåŠ¡åœ°å€: 
  http://localhost:${PORT}`); console.log(`ğŸ“ Webhook ç«¯ç‚¹: http://localhost:${PORT}/webhook`); console.log(`ğŸ”§ 
  å¥åº·æ£€æŸ¥: http://localhost:${PORT}/health`); console.log(`ğŸ§ª é’‰é’‰æµ‹è¯•: 
  http://localhost:${PORT}/test/dingtalk`);
});
module.exports = app;
